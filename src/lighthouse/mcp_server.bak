#!/usr/bin/env python3
"""
Lighthouse MCP Server - HTTP Client for Bridge

This MCP server runs on the HOST and connects to the Bridge running in a CONTAINER.
All Bridge functionality is accessed via HTTP API calls to localhost:8765.

Architecture:
- MCP Server (this file): Runs on HOST, provides tools to Claude Code
- Bridge HTTP Server: Runs in CONTAINER on port 8765
- Communication: HTTP/WebSocket between MCP and Bridge
"""

import asyncio
import json
import logging
import sys
from typing import Any, Dict, List, Optional
from pathlib import Path

import aiohttp
from mcp.server.fastmcp import FastMCP

# Setup logging
logger = logging.getLogger("lighthouse.mcp")
logger.setLevel(logging.INFO)

if not logger.handlers:
    handler = logging.StreamHandler(sys.stderr)
    formatter = logging.Formatter('[MCP] %(asctime)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

# Create FastMCP server instance
mcp = FastMCP("lighthouse-bridge")

# Bridge HTTP API configuration
BRIDGE_URL = "http://localhost:8765"
TIMEOUT = aiohttp.ClientTimeout(total=30)

# Session management
current_session: Optional[Dict[str, str]] = None

async def ensure_session():
    """Ensure we have an active session with the Bridge"""
    global current_session
    
    if current_session:
        return current_session
    
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as session:
            async with session.post(
                f"{BRIDGE_URL}/session/create",
                json={
                    "agent_id": "mcp_server",
                    "ip_address": "127.0.0.1",
                    "user_agent": "LighthouseMCP/1.0"
                }
            ) as resp:
                if resp.status == 200:
                    current_session = await resp.json()
                    logger.info(f"Created session: {current_session.get('session_id')}")
                    return current_session
                else:
                    logger.error(f"Failed to create session: {resp.status}")
                    return None
    except Exception as e:
        logger.error(f"Session creation error: {e}")
        return None

# MCP Tool Definitions

@mcp.tool()
async def lighthouse_get_bridge_status(request: Dict[str, Any]) -> str:
    """Get the current status of the Lighthouse Bridge"""
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as session:
            async with session.get(f"{BRIDGE_URL}/status") as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return json.dumps(data, indent=2)
                else:
                    return f"Error: Bridge returned status {resp.status}"
    except aiohttp.ClientError as e:
        return f"Error: Could not connect to Bridge - {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"

@mcp.tool()
async def lighthouse_validate_command(
    tool_name: str,
    tool_input: Dict[str, Any],
    agent_id: str,
    metadata: Optional[Dict[str, Any]] = None
) -> str:
    """Validate a command through the Bridge's speed layer"""
    session = await ensure_session()
    if not session:
        return json.dumps({"error": "Could not establish session with Bridge"})
    
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as client:
            async with client.post(
                f"{BRIDGE_URL}/validate",
                json={
                    "tool_name": tool_name,
                    "tool_input": tool_input,
                    "agent_id": agent_id,
                    "session_token": session.get("session_token"),
                    "metadata": metadata or {}
                }
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return json.dumps(data, indent=2)
                else:
                    return json.dumps({"error": f"Bridge returned status {resp.status}"})
    except Exception as e:
        return json.dumps({"error": str(e)})

@mcp.tool()
async def lighthouse_create_session(
    agent_id: str,
    ip_address: str,
    user_agent: str,
    metadata: Optional[Dict[str, Any]] = None
) -> str:
    """Create a new authenticated session with the Bridge"""
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as client:
            async with client.post(
                f"{BRIDGE_URL}/session/create",
                json={
                    "agent_id": agent_id,
                    "ip_address": ip_address,
                    "user_agent": user_agent,
                    "metadata": metadata or {}
                }
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return json.dumps(data, indent=2)
                else:
                    return json.dumps({"error": f"Bridge returned status {resp.status}"})
    except Exception as e:
        return json.dumps({"error": str(e)})

@mcp.tool()
async def lighthouse_validate_session(
    session_token: str,
    agent_id: str,
    ip_address: Optional[str] = None,
    user_agent: Optional[str] = None
) -> str:
    """Validate a session token"""
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as client:
            async with client.post(
                f"{BRIDGE_URL}/session/validate",
                json={
                    "session_token": session_token,
                    "agent_id": agent_id,
                    "ip_address": ip_address,
                    "user_agent": user_agent
                }
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return json.dumps(data, indent=2)
                else:
                    return json.dumps({"error": f"Bridge returned status {resp.status}"})
    except Exception as e:
        return json.dumps({"error": str(e)})

@mcp.tool()
async def lighthouse_register_expert(
    agent_id: str,
    agent_type: str,
    capabilities: List[str],
    metadata: Optional[Dict[str, Any]] = None
) -> str:
    """Register an expert agent with the Bridge"""
    session = await ensure_session()
    if not session:
        return json.dumps({"error": "Could not establish session with Bridge"})
    
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as client:
            async with client.post(
                f"{BRIDGE_URL}/expert/register",
                json={
                    "agent_id": agent_id,
                    "agent_type": agent_type,
                    "capabilities": capabilities,
                    "metadata": metadata or {}
                }
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return json.dumps(data, indent=2)
                else:
                    return json.dumps({"error": f"Bridge returned status {resp.status}"})
    except Exception as e:
        return json.dumps({"error": str(e)})

@mcp.tool()
async def lighthouse_delegate_to_expert(
    tool_name: str,
    tool_input: Dict[str, Any],
    target_expert: str,
    metadata: Optional[Dict[str, Any]] = None
) -> str:
    """Delegate a command to an expert through the Bridge"""
    session = await ensure_session()
    if not session:
        return json.dumps({"error": "Could not establish session with Bridge"})
    
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as client:
            async with client.post(
                f"{BRIDGE_URL}/expert/delegate",
                json={
                    "tool_name": tool_name,
                    "tool_input": tool_input,
                    "target_expert": target_expert,
                    "session_token": session.get("session_token"),
                    "metadata": metadata or {}
                }
            ) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    return json.dumps(data, indent=2)
                else:
                    return json.dumps({"error": f"Bridge returned status {resp.status}"})
    except Exception as e:
        return json.dumps({"error": str(e)})

@mcp.tool()
async def lighthouse_health_check() -> str:
    """Check health of both MCP server and Bridge connection"""
    mcp_health = "healthy"
    bridge_health = "unknown"
    
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as session:
            async with session.get(f"{BRIDGE_URL}/health") as resp:
                if resp.status == 200:
                    bridge_health = "healthy"
                else:
                    bridge_health = f"unhealthy (status {resp.status})"
    except Exception as e:
        bridge_health = f"unreachable ({str(e)})"
    
    return json.dumps({
        "mcp_server": mcp_health,
        "bridge_connection": bridge_health,
        "bridge_url": BRIDGE_URL,
        "architecture": "MCP on host, Bridge in container"
    }, indent=2)

# Initialization
async def initialize():
    """Initialize MCP server and check Bridge connection"""
    logger.info("üöÄ Lighthouse MCP Server (HTTP Client) starting...")
    logger.info(f"Bridge URL: {BRIDGE_URL}")
    
    # Check Bridge connection
    try:
        async with aiohttp.ClientSession(timeout=TIMEOUT) as session:
            async with session.get(f"{BRIDGE_URL}/health") as resp:
                if resp.status == 200:
                    logger.info("‚úÖ Successfully connected to Bridge")
                else:
                    logger.warning(f"‚ö†Ô∏è  Bridge returned status {resp.status}")
    except Exception as e:
        logger.error(f"‚ùå Could not connect to Bridge: {e}")
        logger.info("Bridge may not be running. Start the container first.")

# Main entry point
if __name__ == "__main__":
    # Run initialization
    asyncio.run(initialize())
    
    # Run MCP server in stdio mode
    logger.info("Starting MCP server in stdio mode...")
    mcp.run(transport="stdio")